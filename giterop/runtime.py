"""
This module defines the core model and implements the runtime operations of the model.

The state of the system is represented as a collection of Resources
Each resource have a status; inert attributes that describe its state;
 and a list of configurations that manage its state.

Each configurations has a status, list of dependencies and an associated spec
Two kinds of dependencies:
 1. live attributes that the configuration's parameters depend on
 2. other configurations and resources it relies on to function properly and so it's status depends on them

A Job is generated by comparing a list of specs with the last known state of the system
Job runs tasks, each of which has a configuration spec that is executed on the running system
Each task is responsible for running one configuration and records its modifications to the system's state

Resource
Configurator
Configuration
ConfigurationSpec

Task
Job
JobOptions
Runner
"""

import six
import collections
import datetime
import types
from itertools import chain
from ruamel.yaml import YAML
from ruamel.yaml.comments import CommentedMap
yaml = YAML()

from enum import IntEnum
from .util import (GitErOpError, GitErOpTaskError, GitErOpAddingResourceError,
  lookupClass, AutoRegisterClass, ChainMap, toEnum, diffDicts, validateSchema, mergeDicts, intersectDict)
from .eval import Ref, mapValue, serializeValue, evalDict
import logging
logger = logging.getLogger('gitup')

# question: if a configuration failed to apply should that affect the status of the configuration?
# OTOH the previous version of the configuration status is still in effect
# But if the configuration did fail could mean error at global level
# treat failed as a separate dependent configuration that can contribute to aggregate status
# and participate in resource graph
# XXX2 add upgrade required field?
# XXX2 for dependencies checking add a revision field that increments everytime configuration changes?

# XXX3 doc: notpresent is a positive assertion of non-existence while notapplied just indicates non-liveness
# notapplied is therefore the default initial state
S = Status = IntEnum("Status", "ok degraded error pending notapplied notpresent", module=__name__)

# ignore may must
Priority = IntEnum("Priority", "ignore optional required", module=__name__)

# omit discover exist
A = Action = IntEnum("Action", "discover instantiate revert", module=__name__)

class Defaults(object):
  shouldRun = Priority.optional
  canRun = True
  intent = Action.instantiate

# for configuration: same as last task run, but also responsible for its adopted child resources?
# status refers to current state of system not what happened when object was last applied
# semantics of priority / shouldRun / skip
# semantics of notapplied

class Operational(object):
  """
  This is an abstract base class for Jobs, Resources, and Configurations all have a Status associated with them
  and all use the same algorithm to compute their status from their dependent resouces, tasks, and configurations

  # operational: boolean: ok or degraded
  # status: ok, degraded, error, notpresent
  # degraded: non-fatal errors or didn't provide required attributes or if couldnt upgrade
  """

  # XXX3 rename Status to ReadyState, add setter on status instead of setting localStatus?
  # XXX3 add repairable, messages?

  # core properties to override
  @property
  def priority(self):
    return Defaults.shouldRun

  @property
  def localStatus(self):
    return Status.notapplied

  def getOperationalDependencies(self):
    return ()

  @property
  def manualOverideStatus(self):
    return None

  # derived properties:
  @property
  def operational(self):
    return self.status == Status.ok or self.status == Status.degraded

  @property
  def active(self):
    return self.status <= Status.error

  @property
  def status(self):
    if self.manualOverideStatus is not None:
      status = self.manualOverideStatus
      if status >= Status.error:
        return status
    else:
      status = self.localStatus
      if status == Status.error or status == Status.notpresent:
        return status

    return self.aggregateStatus(self.getOperationalDependencies(), status)

  @property
  def required(self):
    return self.priority == Priority.required

  @property
  def lastStateChange(self):
    return None

  @property
  def lastConfigChange(self):
    return None

  @property
  def lastChange(self):
    return max(self.lastStateChange, self.lastConfigChange)

  @staticmethod
  def aggregateStatus(statuses, defaultStatus = Status.notapplied):
    # error if a configuration is required and not operational
    # error if a non-configuration managed child resource is required and not operational
    # degraded if non-required configurations and resources are not operational
    #          or required configurations and resources are degraded
    # ok otherwise

    #any required is pending then aggregate is pending
    #any other are pending only set pending if aggregate is ok
    aggregate = defaultStatus if defaultStatus else Status.notapplied
    for status in statuses:
      assert isinstance(status, Operational), status
      if status.priority == Priority.ignore:
        continue
      elif status.required:
        if not status.operational:
          aggregate = Status.error
          break
        elif status.status == Status.degraded:
          aggregate = Status.degraded
      elif status.status == Status.pending and aggregate <= Status.pending:
        aggregate = Status.pending
      elif not status.operational:
        aggregate = Status.degraded
      elif aggregate == Status.notapplied:
        aggregate = Status.ok
    return aggregate

class OperationalInstance(Operational):
  def __init__(self, status=None, priority=None, manualOveride=None, lastStateChange=None, lastConfigChange=None):
    self._localStatus = toEnum(Status, status)
    self._manualOverideStatus = toEnum(Status, manualOveride)
    self._priority = toEnum(Priority, priority)
    self.dependencies = []
    self._lastStateChange = lastStateChange
    self._lastConfigChange = lastConfigChange
    #self.repairable = False # XXX2
    #self.messages = [] # XXX2

  def getOperationalDependencies(self):
    return self.dependencies

  def localStatus():
    doc = "The localStatus property."
    def fget(self):
      return self._localStatus
    def fset(self, value):
      self._localStatus = value
    def fdel(self):
      del self._localStatus
    return locals()
  localStatus = property(**localStatus())

  def manualOverideStatus():
    doc = "The manualOverideStatus property."
    def fget(self):
      return self._manualOverideStatus
    def fset(self, value):
      self._manualOverideStatus = value
    def fdel(self):
      del self._manualOverideStatus
    return locals()
  manualOverideStatus = property(**manualOverideStatus())

  def priority():
    doc = "The priority property."
    def fget(self):
      return self._priority
    def fset(self, value):
      self._priority = value
    def fdel(self):
      del self._priority
    return locals()
  priority = property(**priority())

  @property
  def lastStateChange(self):
    return self._lastStateChange

  @property
  def lastConfigChange(self):
    return self._lastConfigChange

class _ChildResources(collections.Mapping):
  def __init__(self, resource):
    self.resource = resource

  def __getitem__(self, key):
    return self.resource.findResource(key)

  def __iter__(self):
    return self.resource.getSelfAndDescendents()

  def __len__(self):
    return len(tuple(self))

class ResourceRef(object):
  # ABC requires 'parent' and '_keys'

  def _getProp(self, name):
    if name == '.':
      return self
    elif name == '..':
      return self.parent
    name = name[1:]
    # XXX3 use propmap
    return getattr(self, name)

  def __reflookup__(self, key):
    if not key:
      raise KeyError(key)
    if key[0] == '.':
      return self._getProp(key)

    value = self._keys[key] #_attributes parameters
    return Ref.resolveOneIfRef(value, self)

  def yieldParents(self):
    "yield self and ancestors"
    resource = self
    while resource:
      yield resource
      resource = resource.parent

  @property
  def ancestors(self):
    return list(self.yieldParents())

  @property
  def root(self):
    return self.ancestors[-1]

  @property
  def all(self):
    return self.root._all

class Resource(OperationalInstance, ResourceRef):
  def __init__(self, name='', attributes=None, parent=None,
        spec=None, status=None, priority=None, manualOveride=None):
    OperationalInstance.__init__(self, status, priority, manualOveride)
    self.name = name
    self._attributes = attributes or {}

    # configurations that are affecting the state of the resource
    self.effectiveConfigurations = CommentedMap()

    # affirmatively absent configurations -- i.e. failed to apply or explicitly not present
    # excludedConfigurations are configurations intended as notpresent
    # or an updated configuration that failed to apply
    self.excludedConfigurations = CommentedMap()
    self.parent = parent
    if parent:
      if parent.root.findResource(name):
        raise GitErOpError('can not create resource name "%s" is already in use' % name)
      parent.resources.append(self)
    self.resources = []
    self.spec = spec or {}
    self.attributeManager = None
    self.createdOn = None
    self.createdFrom = None
    self._all = _ChildResources(self) if self.root is self else self.root._all

  def localStatus():
    doc = "The localStatus property."
    def fget(self):
      return self._localStatus
    def fset(self, value):
      if self.root.attributeManager:
        self.root.attributeManager.setStatus(self, value)
      self._localStatus = value
    def fdel(self):
      del self._localStatus
    return locals()
  localStatus = property(**localStatus())

  @property
  def attributes(self):
    """
    attributes should be live values but _attributes will be serialized value
    """
    if not self.root.attributeManager:
      return mapValue(self._attributes, self)
    # returned registered attribute or create a new one
    # attribute class getter resolves references
    return self.root.attributeManager.getAttributes(self)

  @property
  def serializedAttributes(self):
    """
    attributes should be live values but _attributes will be serialized value
    """
    if not self.root.attributeManager:
      return self._attributes
    # returned registered attribute or create a new one
    # attribute class getter resolves references
    return self.root.attributeManager.getSerializedAttributes(self)

  @property
  def _keys(self):
    return self._attributes

  def asRef(self):
    return {"ref": "::%s"% self.name}

  @property
  def configurations(self):
    return ChainMap(self.effectiveConfigurations, self.excludedConfigurations)

  def getOperationalDependencies(self):
    return self.effectiveConfigurations.values()

  def getSelfAndDescendents(self):
    "Recursive descendent including self"
    yield self
    for r in self.resources:
      for descendent in r.getSelfAndDescendents():
        yield descendent

  @property
  def descendents(self):
    return list(self.getSelfAndDescendents())

  def findResource(self, resourceid):
    if self.name == resourceid:
      return self
    for r in self.resources:
      child = r.findResource(resourceid)
      if child:
        return child
    return None

  def __eq__(self, other):
    if self is other:
      return True
    if not isinstance(other, Resource):
      return False
    if not self.lastChange:
      # only support equality if resource has a changeid
      return False
    return self.name == other.name and self.lastChange == other.lastChange

  def setConfiguration(self, configuration):
    name = configuration.name
    added = 'excluded'
    removedEffective = None
    removedExcluded = None

    if configuration.status == Status.notpresent and configuration.intent == Action.revert:
      removedEffective = self.effectiveConfigurations.pop(name, None)
      self.excludedConfigurations[name] = configuration
    elif configuration.status == Status.notapplied:
      # if there's an previous configuration or this configuration didn't change anything
      # put it in excluded configurations
      if not configuration.lastStateChange:
        self.excludedConfigurations[name] = configuration
      elif name in self.effectiveConfigurations and self.effectiveConfigurations[name].status != Status.notapplied:
        self.excludedConfigurations[name] = configuration
      else:
        self.effectiveConfigurations[name] = configuration
        added = 'effective'
        if self.excludedConfigurations.get(name) is configuration:
          removedExcluded = self.excludedConfigurations.pop(name)
    else:
      self.effectiveConfigurations[name] = configuration
      added = 'effective'
      if self.excludedConfigurations.get(name) is configuration:
        removedExcluded = self.excludedConfigurations.pop(name)

    logger.debug("on resource %s set config %s to %s", self.name, name, added)
    if removedExcluded:
      logger.debug("on resource %s remove config %s from excluded", self.name, name)
    if removedEffective:
      logger.debug("on resource %s remove config %s from effective", self.name, name)

  def getAllConfigurationsDeep(self):
    for resource in self.getSelfAndDescendents():
      for config in self.effectiveConfigurations.values():
        yield config
      for config in self.excludedConfigurations.values():
        yield config

class ConfiguratorResult(object):
  """
  If applied is True,
  the current pending configuration is set to the effective, active one
  and the previous configuration is no longer in effect.

  Modified indicates whether the underlying state of configuration,
  was changed i.e. the physically altered the system this configuration represents.

  Readystate reports the Status of the current configuration.
  """
  def __init__(self, applied, modified, readyState=None, results=None):
    self.applied = applied
    self.modified = modified
    self.readyState = readyState

@six.add_metaclass(AutoRegisterClass)
class Configurator(object):
  def __init__(self, configurationSpec):
    self.configurationSpec = configurationSpec

  # yields a JobRequest, TaskRequest or a ConfiguratorResult
  def run(self, task):
    yield None

  def dryRun(self, task):
    yield None

  def canRun(self, task):
    """
    Does this configurator support the requested action and parameters
    given the current state of the resource?
    (e.g. can we upgrade from the previous configuration?)
    """
    return Defaults.canRun

  def shouldRun(self, task):
    """Does this configuration need to be run?"""
    return task.pendingConfig.configurationSpec.shouldRun(task.pendingConfig)

  def checkConfigurationStatus(self, task):
    """Is this configuration still valid?"""
    # XXX2
    # should be called during when checking dependencies
    return Status.ok

# XXX3 versioning:
# configurator api version (encoded in api namespace): semantics of the interface giterop uses
# configurator version: breaking change if interpretation of configuration parameters change
# configuration spec version: encompasses installed version -- what is installed

class ConfigurationSpec(object):
  def __init__(self, name=None, target=None, className=None, majorVersion=None, minorVersion='',
      intent=Defaults.intent, lastAttempt=None,
      parameters=None, parameterSchema=None, requires=None, provides=None):
    assert name and target and className and majorVersion is not None, "missing required arguments"
    self.name = name
    self.target = target # name of owner resource
    self.className = className
    self.majorVersion = majorVersion
    self.minorVersion = minorVersion
    self.intent = intent
    self.lastAttempt = lastAttempt
    self.parameters = parameters or {}
    self.parameterSchema = parameterSchema or {}
    self.requires = requires
    self.provides = provides

  def validateParameters(self, parameters):
    return validateSchema(serializeValue(parameters), self.parameterSchema)

  def findMissingRequirements(self, resource):
    if not self.requires:
      return []
    expanded = serializeValue(resource.attributes)
    return validateSchema(expanded, self.requires)

  def findMissingProvided(self, resource):
    # print('provides', resource.name, self.target, self.provides)
    if not self.provides:
      return []
    if resource.name == self.target:
      spec = self.provides.get('.self')
    elif resource.createdFrom:
      spec = self.provides.get(resource.createdFrom)
    else:
      return []
    if not spec or 'attributesSchema' not in spec:
      return []

    expanded = serializeValue(resource.attributes)
    return validateSchema(expanded, spec['attributesSchema'])

  def create(self):
    return lookupClass(self.className)(self)

  def canRun(self, configuration):
    results = self.findMissingRequirements(configuration.resource)
    return not results

  # XXX2 evaluate priority (resource too??)
  def shouldRun(self, configuration):
    return Defaults.shouldRun

  def resolveParameters(self, configuration):
    return mapValue(self.parameters, configuration)

  # xXX2
  def getPostConditions(self):
    return {}

  def copy(self, **mods):
    args = self.__dict__.copy()
    args.update(mods)
    return ConfigurationSpec(**args)

  def __eq__(self, other):
    if not isinstance(other, ConfigurationSpec):
      return False
    # XXX3 add unit tests
    return (self.name == other.name and self.target == other.target and self.className == other.className
      and self.majorVersion == other.majorVersion and self.minorVersion == other.minorVersion
      and self.intent == other.intent and self.parameters == other.parameters and self.parameterSchema and self.parameterSchema
      and self.requires == other.requires and self.provides == other.provides)

class ResourceChanges(collections.OrderedDict):
  """
  Records changes made by configurations.
  Serialized as the "modifications" properties

  modifications:
    resource1:
      attribute1: newvalue
      attribute2: %delete # if deleted
      .added: # set if resource was added
      .status: # set when status changes, including when removed (Status.notpresent)
  """
  statusIndex = 0
  addedIndex = 1
  attributesIndex = 2

  def __init__(self, changes=None):
    super(ResourceChanges, self).__init__()
    if not changes:
      return
    for k, change in changes.items():
      status = change.pop('.status', None)
      self[k] = [
        None if status is None else Manifest.createStatus(status).localStatus,
        change.pop('.added', None),
        change
      ]

  def sync(self, resource):
    """ Update self to only include changes that are still live"""
    root = resource.root
    for k, v in list(self.items()):
      current = root.findResource(k)
      if current:
        attributes = v[self.attributesIndex]
        if attributes:
          v[self.attributesIndex] = intersectDict(attributes, current.serializedAttributes)
        if v[self.statusIndex] != current._localStatus:
          v[self.statusIndex] = None
      else:
        del self[k]

  def addChanges(self, changes):
    for name, change in changes.items():
      old = self.get(name)
      if old:
        old[self.attributesIndex] = mergeDicts(old[self.attributesIndex], change)
      else:
        self[name] = [None, None, change]

  def addStatuses(self, changes):
    for name, change in changes.items():
      assert not isinstance(change[1], six.string_types)
      old = self.get(name)
      if old:
        old[self.statusIndex] = change[1]
      else:
        self[name] = [change[1], None, {}]

  def addResources(self, resources):
    for resource in resources:
      self[resource['name']] = [None, resource, None]

  def updateChanges(self, changes, statuses, resource):
    self.addChanges(changes)
    self.addStatuses(statuses)
    if resource:
      self.sync(resource)

class Configuration(OperationalInstance, ResourceRef):
  def __init__(self, spec, resource, status=Status.notapplied, dependencies=None):
    super(Configuration, self).__init__(status)
    self.configurationSpec = spec
    assert resource and spec and resource.name == spec.target
    self.parent = self.resource = resource
    self.dependencies = dependencies or {}
    self._parameters = None
    self.resourceChanges = ResourceChanges()

  def priority():
    doc = "The priority property."
    def fget(self):
      if self._priority is None:
        return self.configurationSpec.shouldRun(self)
      else:
        return self._priority
    def fset(self, value):
      self._priority = value
    def fdel(self):
      del self._priority
    return locals()
  priority = property(**priority())

  def getOperationalDependencies(self):
    # XXX1 requires should be part of dependencies
    conditions = chain(self.dependencies.values(), self.configurationSpec.getPostConditions().values())
    for conditionPredicate in conditions:
      yield conditionPredicate(self)

  @property
  def name(self):
    return self.configurationSpec.name

  @property
  def intent(self):
    return self.configurationSpec.intent

  @property
  def parameters(self):
    if self._parameters is None:
      self.refreshParameters()
    return self._parameters

  @property
  def _keys(self):
    return self.parameters

  def refreshParameters(self):
    self._parameters = self.configurationSpec.resolveParameters(self)
    return self._parameters

  def hasParametersChanged(self):
    return self._parameters is not None and self.configurationSpec.resolveParameters(self) != self._parameters

  def findMissingRequirements(self):
    return self.configurationSpec.findMissingRequirements(self.resource)

  def findMissingProvided(self):
    return self.configurationSpec.findMissingProvided(self.resource)

  def asRef(self):
    return {"ref": "::%s::.configurations::%s" % (self.target, self.name)}

  def __eq__(self, other):
    if self is other:
      return True
    if not isinstance(other, Configuration):
      return False
    if not self.lastChange:
      # only support equality if resource has a changeid
      return False
    return (self.name == other.name and self.target == other.target
              and self.lastChange == other.lastChange)

  # XXX3
  # @property
  # def outdated(self):
  #   if self._outdated:
  #     return True
  #   for config in self.dependencies:
  #     if config.outdated:
  #       return True
  #   return False

  #XXX3 like outdated
  #@property
  #def obsolete(self):

class TaskRequest(object):
  def __init__(self, configSpec, persist):
    self.configSpec = configSpec
    # XXX2 persist creates a dependency
    self.persist = persist

class JobRequest(object):
  def __init__(self, resources, errors):
    self.resources = resources
    self.errors = errors

class TaskView(object):
  """
  The interface presented to configurators.
  """
  def __init__(self, manifest, currentConfig):
    self.manifest = manifest
    self.currentConfig = currentConfig
    self.messages = []
    self.addedResources = []
    self.resourceChanges = ResourceChanges()

  def addMessage(self, message):
    self.messages.append(message)

  def _createConfigurationSpecDict(self, configSpec):
    templateName = configSpec.get('template')
    if templateName:
      template = self.currentConfig.configurationSpec.provides.get(
                                        '.configurations', {}).get(templateName)
      if template is None:
        raise GitErOpError('missing config template from provides' % templateName)
      configSpec = mergeDicts(template, configSpec)
    return configSpec

  def createConfigurationSpec(self, name, configSpec, resource=None):
    if isinstance(configSpec, six.string_types):
      configSpec = yaml.load(configSpec)

    if not resource:
      rname = self.currentConfig.resource.name
    elif isinstance(resource, Resource):
      rname = resource.name
    else:
      rname = resource
    return self.manifest.createConfigSpec(name, rname, self._createConfigurationSpecDict(configSpec))

  # configurations created by subtasks are transient insofar as the are not part of the spec,
  # unless marked as persistent. But they are persistent in that they recorded as part of the resource's state and status
  # XXX3 have a way to update spec attributes to trigger config updates e.g. add dns entries via attributes on a dns
  # (for now just rely on away mark a subtask as permanent)

  def createSubTask(self, configSpec, persist=False):
    return TaskRequest(configSpec, persist)

  # XXX2 have indicate what kind of dependency and ownership (e.g. discovered, created)
  def addResources(self, resources):
    """
    Either a list or string that is parsed as YAML
    Operational state indicates if it current exists or not
    Will instantiate a new job, yield it to run that job right away

    - name:
      template: # merge with template
      dependency: required | boolean
      parent:
      attributes:
        override1:
      configurations:
        configname:
          template:
            overrides1
            overrides2
            parameters:
              foo
      status:
        readyState: ok
        attributes:
    """
    if isinstance(resources, six.string_types):
      resources = yaml.load(resources)

    errors = []
    newResources = []
    for resourceSpec in resources:
      try:
        templateName = resourceSpec.get('template')
        if templateName:
          template = self.currentConfig.configurationSpec.provides.get(templateName)
          if template is None:
            raise GitErOpError('missing resource template from provides' % templateName)
          logger.debug('template %s: %s', templateName, template)
          #logger.debug('resourceSpec %s', resourceSpec)
          resourceSpec = mergeDicts(template, resourceSpec)
          #logger.debug('merged resourceSpec %s', resourceSpec)

        configSpecs = resourceSpec.get('configurations', {}).items()
        configurations = dict((name, self._createConfigurationSpecDict(configSpec))
                                              for name, configSpec in configSpecs)
        # logger.debug("configurations %s", configurations)
        rname = resourceSpec['name']
        pname = resourceSpec.get('parent')
        parent = self.findResource(pname) if pname else self.currentConfig.resource.root
        if parent is None:
          raise GitErOpError('can not find parent resource %s' % pname)

        # attributes are part of spec but status can also contain attributes if needed
        resource = self.manifest.createResource(rname, dict(
          status=resourceSpec.get('status', {}),
          spec=dict(configurations=configurations,
                attributes=resourceSpec.get('attributes')
              )
          ), parent)
        resource.createdOn = self.changeId
        resource.createdFrom = templateName
      except:
        errors.append(GitErOpAddingResourceError(self, resourceSpec))
      else:
        newResources.append(resource)

    self.resourceChanges.addResources(resources)
    self.pendingConfig.resourceChanges.addResources(resources)
    self.addedResources.extend(newResources)
    logger.info("add resources %s", newResources)
    jobRequest = JobRequest(newResources, errors)
    if self.job:
      self.job.jobRequestQueue.append(jobRequest)
    return jobRequest

  # XXX2 need an api to get dependencies
  # XXX2 have a way to get changes and mark as dependencies?
  def query(self, query, resource=None, name=None, dependency=None):
    """
    required
    replace=name
    set: value or status
    match:
     result (default) #if result is resource or configuration, any change triggers dependency
     value
     status
     query
     schema
    """
  # dependency = [dependent, required]
  # updates can be marked as dependencies (changes to dependencies changed) or required (error if changed)
  # configuration has cumulative set of changes made it to resources
  # updates update those changes
  # other configurations maybe modify those changes, triggering a configuration change
  # what about previous changes?
  # XXX2
  # setting dependencies and required replace old ones
  # dependencies can be declared separately and with queries
  def updateDependency(self, name, dependencyTemplateName, args=None):
    """
    Dynamically update the conditions this configuration depends on.
    """
    if dependencyTemplateName:
      dependency = self.manifest.createDependency(self.currentConfig.configurationSpec, dependencyTemplateName, args)
      self.currentConfig.dependencies.update(name, dependency)
    else:
      self.currentConfig.dependencies.pop(name, None)

  def findResource(self, name):
     return self.manifest.getRootResource().findResource(name)

  def createResult(self, applied, modified, readyState=None, results=None):
    return ConfiguratorResult(applied, modified, readyState, results)

class AttributeManager(object):
  def __init__(self):
    self.attributes = {}
    self.statuses = {}

  def setStatus(self, resource, newvalue):
    assert newvalue is None or isinstance(newvalue, Status)
    if resource.name not in self.statuses:
      self.statuses[resource.name] = [resource._localStatus, newvalue]
    else:
      self.statuses[resource.name][1] = newvalue

  def getSerializedAttributes(self, resource):
    self.getAttributes(resource) # merge and serialize attributes
    return self.attributes[resource.name][2]

  def getAttributes(self, resource):
    if resource.name not in self.attributes:
      specd = mapValue(resource.spec.get('attributes', {}), resource)
      attributes = mapValue(resource._attributes, resource)
      specd.update(attributes)
      self.attributes[resource.name] = (resource, specd, serializeValue(specd))
      return specd # converted to live refs
    else:
      return self.attributes[resource.name][1]

  def revertChanges(self):
    self.attributes = {}
    # for resource, old, new in self.statuses.values():
    #   resource._localStatus = old

  def commitChanges(self):
    changes = {}
    for resource, attributes, original in self.attributes.values():
      # 1. convert to back json (refs)
      serialized = serializeValue(attributes)
      # 2. diff with resource._attributes
      diff = diffDicts(original, serialized)
      if not diff:
        continue
      # 3. save diff
      changes[resource.name] = diff
      # 4. update resource
      resource._attributes = serialized
    self.attributes = {}
    # self.statuses = {}
    return changes

class Task(TaskView, AttributeManager):
  """
  Configurator records the changes to the system's state via the Task interface

  Find resources
  record new resources
  modify / delete resources
  record / update / remove dependencies expressed as conditions
   (by updating and/or instantiating the ones defined in the spec)

  Configurator's only other interface to modifying the system is through createSubTask()
  """
  def __init__(self, job, spec, currentConfig, parentId=None, reason = None):
    TaskView.__init__(self, job.runner.manifest, currentConfig)
    AttributeManager.__init__(self)
    self.changeId = job.runner.incrementChangeId()
    self.parentId = parentId or job.changeId
    self.reason = reason
    spec.lastAttempt = self.changeId

    self.previousConfig = currentConfig
    if currentConfig:
      self.currentConfig = currentConfig
      self.pendingConfig = Configuration(spec, currentConfig.resource, Status.notapplied)
    else:
      resource = self.findResource(spec.target)
      if not resource:
        raise GitErOpTaskError(self, "could not find configuration resource %s" % spec.target)
      self.pendingConfig = Configuration(spec, resource, Status.notapplied)
      self.currentConfig = self.pendingConfig

    self.configurator = spec.create()
    self.errors = []
    self.startTime = job.startTime or datetime.datetime.now()
    self.dryRun = job.dryRun
    self.generator = None
    self.job = job
    self.changeList = []
    self.changeSet = None

  def validateParameters(self):
    spec = self.pendingConfig.configurationSpec
    return not spec.validateParameters(
                  spec.resolveParameters(self.pendingConfig))

  def start(self):
    self.startRun()
    # set the attribute manager on the root resource
    self.currentConfig.resource.root.attributeManager = self

    # set currentConfig (on the target resource too)
    # XXX2 set status to pending?
    config = self.pendingConfig
    self.currentConfig = config
    config.resource.setConfiguration(config)
    config.refreshParameters()

  def startRun(self):
    if self.dryRun:
      self.generator = self.configurator.dryRun(self)
    else:
      self.generator = self.configurator.run(self)
    assert isinstance(self.generator, types.GeneratorType)

  def send(self, change):
    result = None
    try:
      result = self.generator.send(change)
    finally:
      # we serialize configurations
      if result == Status.notapplied:
        self.revertChanges()
      else:
        self.commitChanges()
    return result

  def processResult(self, result):
    # applied indicates this configuration is active
    # modified indicates if a "physical" change to this system was made
    # (all combinations of these two are permissible)
    if result.modified:
      self.pendingConfig._lastStateChange = self.changeId

    if result.applied:
      self.pendingConfig._lastConfigChange = self.changeId
      assert result.readyState and result.readyState != Status.notapplied
      self.pendingConfig.localStatus = result.readyState
    else:
      self.pendingConfig.localStatus = Status.notapplied
      if self.previousConfig:
        if result.modified:
          self.previousConfig._lastStateChange = self.changeId
        if result.readyState and result.readyState != self.previousConfig.localStatus:
          assert result.readyState != Status.notapplied
          self.previousConfig.status = result.readyState
          self.previousConfig._lastConfigChange = self.changeId

    self.pendingConfig.resource.setConfiguration(self.pendingConfig)

  def finished(self, result):
    if self.generator:
      self.generator.close()
      self.generator = None

    self.processResult(result)
    #XXX2 Check that configuration provided the metadata that it declared it would provide
    resource = self.currentConfig.resource

    if (result.applied or result.modified) and self.changeList:
      # merge changes together (will be saved with changeset)
      changes = self.changeList
      accum = changes.pop(0)
      while changes:
        accum = mergeDicts(accum, changes.pop(0))

      self.resourceChanges.updateChanges(accum, self.statuses, resource)
      self.pendingConfig.resourceChanges.updateChanges(accum, self.statuses, resource)

    return self.pendingConfig

  def commitChanges(self):
    changes = AttributeManager.commitChanges(self)
    self.changeList.append(changes)
    return changes

  def __repr__(self):
    return "Task(%s:%s %s)" % (
      self.pendingConfig.resource.name,
      self.pendingConfig.name,
      self.reason or 'unknown'
    )

class JobOptions(object):
  """
  Options available to select which tasks are run, e.g. read-only

  does the config apply to the action?
  is it out of date?
  is it in a ok state?
  """
  defaults = dict(
    parentJob=None,
    startTime=None,
    out=None,

    resource=None,
    resources=None,
    configuration=None,

    # default options:
    add=True, # run newly added configurations
    update=True, # run configurations that whose spec has changed but don't require a major version change
    repair="error", # or 'degraded' or "notapplied" or "none", run configurations that are not operational and/or degraded

    upgrade=False, # run configurations with major version changes or whose spec has changed
    all=False, # (re)run all configurations
    verify=False, # XXX3 discover first and set status if it differs from expected state
    readOnly=False, # only run configurations that won't alter the system
    dryRun=False, # XXX2
    requiredOnly=False,
    revertObsolete=False #revert
    )

  def __init__(self, **kw):
    options = self.defaults.copy()
    options.update(kw)
    self.__dict__.update(options)

class Job(OperationalInstance):
  def __init__(self, runner, rootResource, specs, jobOptions):
    super(Job, self).__init__(Status.ok)
    assert isinstance(jobOptions, JobOptions)
    self.__dict__.update(jobOptions.__dict__)
    self.jobOptions = jobOptions
    self.runner = runner
    self.wantedSpecs = specs
    self.rootResource = rootResource
    self.jobRequestQueue = []
    self.unexpectedAbort = None
    self.changeId = runner.incrementChangeId()
    self.parentId = self.parentJob.changeId if self.parentJob else None
    self.workDone = collections.OrderedDict()

  def runJobRequest(self, jobRequest):
    self.jobRequestQueue.remove(jobRequest)
    resourceNames=[r.name for r in jobRequest.resources]
    jobOptions = JobOptions(parentJob=self, repair='none',
      resources=resourceNames)
    specs = []
    for r in jobRequest.resources:
      if 'configurations' in r.spec:
        specs.extend(r.spec['configurations'].values())
    childJob = Job(self.runner, self.rootResource.root, specs, jobOptions)
    assert childJob.parentJob is self
    childJob.run()
    return childJob

  def includeTask(self, config, lastChange):
    """
spec (config):
  intent: discover instantiate revert
  config
  version

status (lastChange):
  state: ok degraded error notpresent
  Current runtime state compared to requirements for last applied spec:
    no longer needed, misconfigured / parameters changed, error/degraded, missing/should be applied
    (only discovered at runtime as state is updated but persisted for next run)
  action: discover instantiate revert

status compared to current spec is different: compare difference for each:
  config: same different missing orphan
  intent vs. action: (d, i) (i, d) (i, r) (r, i) (d, r) (r, d)
  version: newer older
    """
    assert config or lastChange
    if self.all and config:
      return 'all', config
    if config and not lastChange:
      if config.lastAttempt:
        if self.repair == 'notapplied':
          return 'failed to apply', config
        else:
          return None
      if self.add:
        # XXX3 what if config.intent == A.revert? return None?
        return 'add', config
      else:
        return None
    spec = lastChange.configurationSpec
    if lastChange and not config:
      if self.revertObsolete:
        return 'revert obsolete', spec.copy(intent=A.revert)
      if self.all:
        return 'all', spec
      # use lastAttempt to distinguish between a change that was never applied and one that failed to apply
      if lastChange.status == S.notapplied and not spec.lastAttempt and self.add:
        return 'never applied', spec
    elif spec != config:
      # the user changed the configuration (including parameters):
      if self.upgrade:
        return 'upgrade', config
      if lastChange.status == S.notpresent and spec.intent != config.intent and self.add:
        # this case is essentially a re-added config, so re-run it
        return 're-add', config
      if self.update:
        # apply the new configuration unless it will trigger a major version change
        if config.intent != A.revert and spec.majorVersion != config.majorVersion:
          return 'update', config

    # there isn't a new config to run, see if the last applied config needs to be re-run
    # XXX1 what about dependencies / required changed pretty much the same as hasParametersChanged()
    assert lastChange
    if lastChange.hasParametersChanged() and (self.update or self.all):
      return 'config changed', lastChange.configurationSpec

    return self.checkForRepair(lastChange)

  def checkForRepair(self, lastChange):
    assert lastChange
    spec = lastChange.configurationSpec

    if self.repair=="none":
      return None
    status = lastChange.status
    if status == S.notapplied and lastChange.required:
      status = S.error # treat as error

    # repair should only apply to configurations that are active and in need of repair
    # XXX2 what about pending??
    if status not in [S.degraded, S.error, S.notapplied]:
      return None

    if status == S.notapplied:
      if self.repair == 'notapplied':
        return 'failed to apply', spec
      else:
        return None
    if self.repair == "degraded":
      assert status > S.ok, status
      return 'degraded', spec # repair this
    elif status == S.degraded:
      assert self.repair == 'error', self.repair
      return None # skip repairing this
    else:
      assert self.repair == 'error', "repair: %s status: %s" % (self.repair, lastChange.status)
      return 'error', spec # repair this

  def getCurrentConfigurations(self):
    return self.rootResource.getAllConfigurationsDeep()

  def findConfigurations(self, resource):
    for config in self.wantedSpecs:
      if config.target == resource.name:
        yield config
      # XXX3 to support rule-based configurations:
      # if config.matches(resource):
      #   if config.isTemplate:
      #     yield config.copy(target=resource.name)
      #   else:
      #     yield config

  # predictability, clarity, static analysis
  # correctness: state changes are live
  # simplicity / understandable, easy to use and implement
  # state changes may place prior configurations in a obsolete, error/degraded, or outdated/misconfigured state
  def getCandidateTasks(self):
    """
    Find candidate tasks

    Given declared spec, current status, and job options, generate selector

    does the config apply to the action?
    is it out of date?
    is it in a ok state?
    has its configuration changed?
    has its dependencies changed?
    are the resources it modifies in need of repair?
    manual override (include / skip)

    # intent: discover instantiate revert
    # version
    # configuration
    """
    # list of resources yielded here may dynamically change if tasks are run during iteration
    # we do this so as to reflect the state of the system as accurately as possible when tasks are run
    # but this means added resources whose parent has already been iterated over would be skipped
    # and updates to a resource already iterated over may render it inconsistent with the last run
    for resource in self.rootResource.getSelfAndDescendents():
      existing = resource.effectiveConfigurations.copy()
      excluded = resource.excludedConfigurations.copy()
      for config in self.findConfigurations(resource):
        if self.runner.isConfigAlreadyHandled(config):
          # configuration may have premptively run while executing another task
          continue
        lastChange = existing.pop(config.name, None)
        if not lastChange:
          lastChange = excluded.pop(config.name, None)
        include = self.includeTask(config, lastChange)
        if include:
          reason, config = include
          if self.filterConfig(config):
            yield self.createTask(config, lastChange, reason=reason)
        else:
          logger.info("skipping config %s:%s", config.target, config.name)

      if self.all or self.revertObsolete:
        for change in existing.values():
          # it's an orphaned config
          include = self.includeTask(None, change)
          if not include:
            continue
          reason, config = include
          if self.runner.isConfigAlreadyHandled(config):
            # configuration may have premptively run while executing another task
            continue
          if self.filterConfig(config):
            yield self.createTask(config, change, reason=reason)

  def filterConfig(self, config):
    if self.readOnly and config.intent != 'discover':
      return None
    if self.requiredOnly and not config.required:
      return None
    if self.resource and config.target != self.resource:
      return None
    if self.resources and config.target not in self.resources:
      return None
    if self.configuration and config.name != self.configuration:
      return None
    return config

  def createTask(self, configSpec, config, parentId=None, reason=None):
    task = Task(self, configSpec, config, parentId, reason = reason)
    return task

  def runTask(self, task):
    """
    During each task run:
    * Notification of metadata changes that reflect changes made to resources
    * Notification of add or removing dependency on a resource or properties of a resource
    * Notification of creation or deletion of a resource
    * Requests a resource with requested metadata, if it doesn't exist, a task is run to make it so
    (e.g. add a dns entry, install a package).
    """
    # XXX3 need a way for configurator to declare that is the manager of a particular resource or type of resource or metadata so we know to handle that request
    # XXX3 recursion or loop detection
    if not self.canRunTask(task):
      return task.finished(ConfiguratorResult(False, False))

    task.start()
    change = None
    while True:
      try:
        result = task.send(change)
      except Exception:
        GitErOpTaskError(task, "configurator.run failed")
        # assume the worst
        return task.finished(ConfiguratorResult(True, True, Status.error))
      if isinstance(result, TaskRequest):
        subtask = self.createTask(result.configSpec, None, task.changeId)
        self.runner.addWork(subtask)
        change = self.runTask(subtask) # returns a configuration
      elif isinstance(result, JobRequest):
        job = self.runJobRequest(result)
        change = job
      elif isinstance(result, ConfiguratorResult):
        return task.finished(result)
      else:
        GitErOpTaskError(task, 'unexpected result from configurator')
        return task.finished(ConfiguratorResult(True, True, Status.error))

  def run(self):
    for task in self.getCandidateTasks():
      self.runner.addWork(task)
      if not self.shouldRunTask(task):
        continue

      logger.info("running task %s", task)
      self.runTask(task)
      if not self.parentJob:
        # only check when running top level tasks
        self.localStatus = self.checkStatusAfterRun()

      if self.shouldAbort(task):
        return self.rootResource

    # the only jobs left will be those that were added to resources already iterated over
    # and were not yielding inside runTask
    while self.jobRequestQueue:
      jobRequest = self.jobRequestQueue[0]
      job = self.runJobRequest(jobRequest)
      if self.shouldAbort(job):
        return self.rootResource

    if not self.parentJob:
      # create a job will re-run configurations whose parameters or dependencies have changed
      maxloops = 10 # XXX3 better loop detection
      for count in range(maxloops):
        job = Job(self.runner, self.rootResource, [],
                    JobOptions(parentJob=self, repair='none'))
        job.run()
        # break when there are no more tasks to run
        if not len(job.workDone) or self.shouldAbort(job):
          break
      else:
        raise GitErOpError("too many final dependency runs")

    return self.rootResource

  def shouldRunTask(self, task):
    """
    Checked at runtime right before each task is run

    * check "when" conditions to see if it should be run
    * check task if it should be run
    """
    try:
      priority = task.configurator.shouldRun(task)
    except Exception:
      #unexpected error don't run this
      GitErOpTaskError(task, "shouldRun failed")
      return False

    task.pendingConfig.priority = priority
    return priority > Priority.ignore

  def canRunTask(self, task):
    """
    Checked at runtime right before each task is run

    * validate parameters
    * check "required"/pre-conditions to see if it can be run
    * check task if it can be run
    """
    try:
      canRun = (task.validateParameters()
              and task.pendingConfig.configurationSpec.canRun(task.pendingConfig)
              and task.configurator.canRun(task))
    except Exception:
      GitErOpTaskError(task, "canRun failed")
      canRun = False

    if canRun:
      return True
    else:
      return False

  def shouldAbort(self, task):
    return False #XXX2

  def summary(self):
    return "XXX2"

  def checkStatusAfterRun(self):
    """
    After each task has run:
    * Check dependencies:
    ** check that runtime-(post-)conditions still hold for configurations that might have been affected by changes
    ** check for configurations whose parameters might have been affected by changes, mark them as "configuration changed"
    (simple implementation for both: check all configurations (requires saving previous inputs))
    """
    #* XXX3 check for orphaned resources and mark them as orphaned
    #  (a resource is orphaned if it was added as a dependency and no longer has dependencies)
    #  (orphaned resources can be deleted by the configuration/configurator that created them or manages that type)
    def yieldAllDependencies():
      for configuration in self.getCurrentConfigurations():
        for dependency in configuration.getOperationalDependencies():
          yield dependency

    return Operational.aggregateStatus(yieldAllDependencies())

  def getOperationalDependencies(self):
    # XXX2 this isn't right, root job might have too many and child job might not have enough
    # plus dynamic configurations probably shouldn't be included if yielded by a configurator
    for task in self.workDone.values():
      yield task.currentConfig

class Manifest(AttributeManager):
  def __init__(self, rootResource, specs, templates=None, lastChangeId=0):
    super(Manifest, self).__init__()
    self.rootResource = rootResource
    rootResource.attributeManager = self
    self.specs = specs
    self.templates = templates or {}
    self.lastChangeId=lastChangeId

  def getRootResource(self):
    return self.rootResource

  def getConfigurationSpecs(self):
    return self.specs

  def createDependency(self, configurationSpec, dependencyTemplateName, args=None):
    return None

  def saveJob(self, job):
    pass

  @staticmethod
  def createStatus(status, instance=None):
    if not instance:
      instance = OperationalInstance()
    if not status:
      return instance

    instance._priority = toEnum(Priority, status.get('priority'))
    instance._lastStateChange = status.get('lastStateChange')
    instance._lastConfigChange = status.get('lastConfigChange')

    readyState = status.get('readyState')
    if not isinstance(readyState, dict):
      instance._localStatus = toEnum(Status, readyState)
    else:
      instance._localStatus = toEnum(Status, readyState.get('local'))

    return instance

  @staticmethod
  def createConfigSpec(configName, resourceName, spec):
    return ConfigurationSpec(configName, resourceName, spec['className'],
          spec['majorVersion'], spec.get('minorVersion',''),
          intent=toEnum(Action, spec.get('intent', Defaults.intent)),
          lastAttempt=spec.get('lastAttempt'),
          parameters=spec.get('parameters'), parameterSchema=spec.get('parameterSchema'),
          requires=spec.get('requires'), provides=spec.get('provides'))

  def createResource(self, name, decl, parent):
    status = decl.get('status', {})
    specs = decl['spec']
    configSpecs = CommentedMap([(key, self.createConfigSpec(key, name, val))
                              for key, val in specs['configurations'].items()])
    self.specs.extend(configSpecs.values())
    operational = self.createStatus(status)
    resource = Resource(name, status.get('attributes'), parent,
        spec=CommentedMap([
          ("attributes", specs.get('attributes')),
          ("configurations", configSpecs)
        ]),
        status=operational.localStatus)
    resource.createdOn = status.get('createdOn')
    resource.createdFrom = status.get('createdFrom')
    for configSpec in configSpecs.values():
      if not configSpec.lastAttempt:
        continue
      changeSet = self.changeSets.get(configSpec.lastAttempt)
      if changeSet:
        changeSetStatus = self.createStatus(changeSet)
        if changeSetStatus.status in [Status.notapplied, Status.notpresent]:
          # these will not be in the status' configurations so set them now
          excluded = Configuration(configSpec, resource, changeSetStatus.localStatus)
          self.createStatus(changeSet, excluded)
          resource.setConfiguration(excluded)

    for key, val in status.get('configurations', {}).items():
      # change = self.changeSets.get(val['changeid']); change['spec']
      configSpec = self.createConfigSpec(key, name, val['spec'])
      config = Configuration(configSpec, resource)
      self.createStatus(val, config)
      # XXX1 load dependencies
      resource.setConfiguration(config)
      config.resourceChanges = ResourceChanges(val.get('modifications', {}))

    for key, val in decl.get('resources', {}).items():
      self.createResource(key, val, resource)

    return resource

class Runner(object):
  def __init__(self, manifest):
    self.manifest = manifest
    self.lastChangeId = manifest.lastChangeId
    self.currentJob = None

  def addWork(self, task):
    config = task.currentConfig
    key = (config.resource.name, config.name)
    self.currentJob.workDone[key] = task
    task.job.workDone[key] = task

  def isConfigAlreadyHandled(self, configSpec):
    return (configSpec.target, configSpec.name) in self.currentJob.workDone

  def createJob(self, joboptions):
    """
    Selects task to run based on job options and starting state of manifest
    """
    return Job(self, self.manifest.getRootResource(), self.manifest.getConfigurationSpecs(), joboptions)

  def incrementChangeId(self):
    self.lastChangeId +=1
    return self.lastChangeId

  def run(self, joboptions=None):
    """
    """
    if joboptions is None:
      joboptions = JobOptions()
    job = self.createJob(joboptions)
    self.currentJob = job
    try:
      job.run()
    except Exception:
      job.localStatus = Status.error
      job.unexpectedAbort = GitErOpError("unexpected exception while running job", True)
    self.currentJob = None
    self.manifest.saveJob(job)
    return job
