"""
This module defines the core model and implements the runtime operations of the model.

The state of the system is represented as a collection of Resources
Each resource have a status; inert attributes that describe its state;
 and a list of configurations that manage its state.

Each configurations has a status, list of dependencies and an associated spec
Two kinds of dependencies:
 1. live attributes that the configuration's parameters depend on
 2. other configurations and resources it relies on to function properly and so it's status depends on them

A Job is generated by comparing a list of specs with the last known state of the system
Job runs tasks, each of which has a configuration spec that is executed on the running system
Each task is responsible for running one configuration and records its modifications to the system's state

Resource
Configurator
ConfiguratorSpec
Configuration
ConfigurationSpec

Task
Job
JobOptions
Runner
"""

import six
from enum import IntEnum
from .util import *

def toEnum(enum, value):
  #from string: Status[name]; to string: status.name
  if isinstance(value, six.string_types):
    return enum[value]
  else:
    return value

# XXX2 notapplied
S = Status = IntEnum("Status", "ok degraded error notapplied notpresent", module=__name__)

Priority = ShouldRun = IntEnum("Priority", "skip optional required", module=__name__)

A = Action = IntEnum("Action", "discover instantiate revert", module=__name__)

class Defaults(object):
  shouldRun = Priority.optional
  canRun = True

# for configuration: same as last task run, but also responsible for its adopted child resources?
class Operational(object):
  """
  This is an abstract base class for Jobs, Resources, and Configurations all have a Status associated with them
  and all use the same algorithm to compute their status from their dependent resouces, tasks, and configurations

  # operational: boolean: ok or degraded
  # status: ok, degraded, error, notpresent
  # degraded: non-fatal errors or didn't provide required attributes or if couldnt upgrade
  """

  # XXX0 all derived classes need to define instance members or get properties for the following:
  # computedStatus, manualOverideStatus, priority
  # mergeStatus requires setters too
  # XXX2 and repairable, messages?

  @property
  def operational(self):
    return self.status == Status.ok or self.status == Status.degraded

  @property
  def status(self):
    return self.manualOverideStatus or self.computedStatus

  @property
  def required(self):
    return self.priority == Priority.required

  def getStatusDependencies(self):
    return ()

  @staticmethod
  def aggregateStatus(statuses, defaultStatus = Status.ok):
    # error if a configuration is required and not operational
    # error if a not configuration managed child resource is required and not operational
    # notpresent if not present
    # degraded non-required configurations and resources are not operational
    #          or required configurations and resources are degraded
    # ok otherwise
    state = defaultStatus
    for status in statuses:
      if state >= Status.error:
        continue
      if status.required:
        if not status.operational:
          state = Status.error
        elif status.state == Status.degraded:
          state = Status.degraded
      elif not status.operational:
          state = Status.degraded
    return state

  def mergeStatus(self):
    merged = self.aggregateStatus(self.getStatusDependencies())
    # if merged state is worse, use merged state
    if self.status < merged.status:
      if self.manualOverideStatus:
        if self.computedStatus < merged.status:
          #if things have gotten worse then the current computed state clear the manual override
          #XXX2 this really should only do this if new child statuses are in a worse state
          # right now we won't clear the override if aggregate state didn't worsen
          self.manualOverideStatus = None
      self.computedStatus = merged.status

class OperationalValue(Operational):
  def __init__(self, status=None, priority=None, manualOveride=None):
    self.computedStatus = toEnum(Status, status)
    self.manualOverideStatus = toEnum(Status, manualOveride)
    self.priority = toEnum(Priority, priority)
    #self.repairable = False # XXX2
    #self.messages = [] # XXX2

class Resource(Operational):
  def __init__(self, name='', attributes=None, configurations=None, parent=None, children=None):
    self.name = name
    self.attributes = attributes or []
    self.configurations = dict((c.name, c) for c in (configurations or []))
    self.container = parent
    self.parts = children or []

  def getStatusDependencies(self):
    return self.configurations.values()

  def getSelfAndDescendents(self):
    """Recursive descendent including self"""
    yield self
    for r in self.parts:
      for descendent in r.yieldDescendents():
        yield descendent

  @property
  def descendents(self):
    return list(self.getSelfAndDescendents())

  def findConfiguration(self, name):
    return self.configurations.get(name):

  def findResource(self, resourceid):
    if self.name == resourceid:
      return self
    for r in self.parts:
      if r.name == resourceid:
        return match
    return None

  def yieldParents(self):
    """yield self and ancestors"""
    resource = self
    while resource:
      yield resource
      resource = resource.container

  @property
  def ancestors(self):
    return list(self.yieldParents())

  @property
  def root(self):
    return self.ancestors[-1]

  def createResource(self, name, attributes=None, parent=None, configurationSpecs=None):
    resource = Resource(name, attributes, parent=parent or self.root)
    if configurationSpecs:
      for spec in configurationSpecs:
        resource.setConfiguration(Configuration(spec, self))
    return resource

  def setConfiguration(self, configuration):
    self.configurations[configuration.name] = configuration

class Configurator(object):
  def __init__(self, configuratorSpec):
    self.configuratorSpec = configuratorSpec

  def run(self, task):
    yield None

  def dryRun(self, task):
    yield None

  def canRun(self, task):
    """
    Does this configurator support the requested action and parameters
    given the current state of the resource?
    (e.g. can we upgrade from the previous configuration?)
    """
    return Defaults.canRun

  def shouldRun(self, task):
    """Does this configuration need to be run?"""
    return task.configurationSpec.shouldRun(task.newConfiguration)

  def checkConfigurationStatus(self, task):
    """Is this configuration still valid?"""
    # called during when checking dependencies
    return Status.ok

# XXX2 add one parameter variant of registerClass(klass) that extracts name and version from class
registerClass(VERSION, "Configurator", Configurator)

class ConfiguratorSpec(object):
  def __init__(self, name, className, majorVersion, minorVersion='', actions=None, schema=None):
    self.name = name
    self.className = className
    self.majorVersion = majorVersion
    self.minorVersion = minorVersion
    self.parameterSchema = schema or {} # XXX1 change to validate predictate?
    # XXX1 supportedActions should be checked by canRun()
    self.supportedActions = actions

  def create(self):
    return lookupClass(self.className)(self)

  def __eq__(self, other):
    if not isinstance(other, ConfiguratorSpec):
      return False
    # XXX1 update equality with func classes so parameterSchema compare properly
    return (self.name == other.name and self.className == other.className
      and self.majorVersion == other.majorVersion and self.minorVersion == other.minorVersion
      and self.parameterSchema == other.parameterSchema and self.actions == other.actions)

# XXX2 document versions:
# configurator api version (encoded in api namespace): semantics of the interface giterop uses
# configurator version: breaking change if meaning of configuration parameters change
# configuration spec version: encompasses installed version -- what is installed

#XXX1 __reflookup__ on Resource and Configuration, think about ref syntax again!
def evaluate(currentConfig, value, default=None):
  if Ref.isRef(value):
    result = Ref(value).resolveOne(currentConfig)
  else:
    result = value
  return default if result is None else result

# XXX2 this could be part of the configurationSpec subclass:
# return evaluate(self.previousRun, self.configurationSpec.canRun, Defaults.canRun)
# return evaluate(configuration, self.configurationSpec.shouldRun, Defaults.shouldRun)

class Predicate(object):
  # XXX2 save() and restore()

  def evaluate(self, configuration): return self.default

  def __eq__(self, other):
    if not isinstance(other, Predicate):
      return False
    return True

class ConfigurationSpec(object):
  def __init__(self, name, target, configuratorSpec, majorVersion, minorVersion='', params=None,
      intent=A.instantiate, postConditions=None
      canRun=lambda configuration: Defaults.canRun,
      shouldRun=lambda configuration: Defaults.shouldRun):
    self.name = name
    self.target = target # name of owner resource
    self.configuratorSpec = configuratorSpec
    self.majorVersion = majorVersion
    self.minorVersion = minorVersion
    self.params = params or {}
    # map<name: configuration => Operational>
    self.postConditions = postConditions or {}
    # XXX2 add ensures
    self.intent = intent
    self.canRun = canRun
    self.shouldRun = shouldRun

  def copy(self, **mods):
    args = self.__dict__.copy()
    args.update(mods)
    return ConfigurationSpec(**args)

  def __eq__(self, other):
    if not isinstance(other, ConfigurationSpec):
      return False
    # update equality with func classes so conditions, canRun and shouldRun compare properly
    return (self.name == other.name and self.targt == other.target and self.configuratorSpec == other.configuratorSpec
      and self.majorVersion == other.majorVersion and self.minorVersion == other.minorVersion
      and self.intent == other.intent and self.require == other.required
      and self.params == other.params and self.conditions == other.conditions)

class Configuration(Operational):
  """
  configurationSpec
  status
  resource
  """
  #XXX0
  def __init__(self, spec, resource, status=Status.notapplied):
    # super(Operational, self).__init__(status)
    self.configurationSpec = spec
    assert resource and spec and resource.name == spec.target
    self.resource = resource
    self.computedStatus = Status.notapplied

    # XXX0
    # dependencies are basically equivalent to requires
    # derived from metadata updates?
    # self._outdated = outdated

  #@property()
  #def computedStatus(self):
  # return _computedStatus or self.statusFromConditions()

  def statusFromConditions(self):
      return self.aggregateStatus(conditionPredicate(self))
        for conditionPredicate in self.configurationSpec.postConditions.values())

  @property
  def name(self):
    return self.configurationSpec.name

  @property
  def priority(self):
    return self.configurationSpec.canRun(self)

  @property
  def outdated(self):
    if self._outdated:
      return True
    for config in self.dependencies:
      if config.outdated:
        return True
    return False

  #XXX2 like outdated
  #@property
  #def obsolete(self):

class Task(object):
  """
  Configurator records the changes to the system's state via the Task interface

  Find resources
  record new resources
  modify / delete resources
  record / update / remove dependencies expressed as conditions
   (by updating and/or instantiating the ones defined in the spec)

  Configurator's only other interface to modifying the system is through createSubTask()
  """
  def __init__(self, job, spec, currentConfiguration):
    self.job = job
    self.oldConfiguration = currentConfiguration
    if currentConfiguration:
      self.currentConfiguration = currentConfiguration
      # new configuration's status starts out as the previous one
      self.newConfiguration = Configuration(spec, currentConfiguration.resource, currentConfiguration.status)
    else:
      resource = self.findResource(spec.target)
      self.newConfiguration = Configuration(spec, currentConfiguration.resource, Status.notapplied)
      self.currentConfiguration = self.newConfiguration
    self.configurator = spec.configuratorSpec.create()

  def validateParams(self):
    return True # XXX2

  def start(self):
    if self.job.dryRun:
      generator = self.configurator.dryRun(self)
    else:
      generator = self.configurator.run(self)
    # set currentConfiguration (on the target resource too)
    self.currentConfiguration = self.newConfiguration
    self.currentConfiguration.resource.setConfiguration(self.newConfiguration)
    return generator

  def finished(self, result):
    # if the status is notapplied when finished set currentConfiguration back to the previous one
    if result == Status.notapplied and self.oldConfiguration:
      self.currentConfiguration = self.oldConfiguration
      self.currentConfiguration.resource.setConfiguration(self.oldConfiguration)

  # def findResource(self, query):
  #   raise 'XXX2'

  def addResource(self, metadata, persistOptions):
    # XXX0 instantiate new resource and a task that will run it
    resource = self.job.createResource(metadata)
    # configurator can yield the returned task if it wants it to be run right away
    # otherwise it will be run later
    return self.job.addChildTask(self, Task(resource))

  #create, update or delete a resource, persistOptions include 'create discover delete forget'?
  def updateResource(self, changes, persistOptions):
    # does this queue tasks?
    pass

  # XXX0
  def updateDependency(self, name, CallbackConfigurationToHasStatus):
    """
    Dynamically update the conditions this configuration depends on.
    """
    pass

  # XXX0
  # def notifyResourceChange(self, resource, change='create discover delete forget'):
  #   pass
  #
  # def updateAttributes(self, attrs):
  #   pass
  #
  # def addMessage(self, message):
  #   pass

  # XXX1 need a way to associate resource templates with constructor / controller configs
  #def createResource(self, resource):
  #  return Task(self, resource)

  def createConfigurationSpec(self, params):
    pass #XXX2

  # configurations created by subtasks are transient insofar as the are not part of the spec,
  # but they are persistent in that they recorded as part of the resource's state and status
  def createSubTask(self, configSpec):
    return Task(self.job, configuration)

  def __str__(self):
    return "Task: " + str(self.configuration)

class JobOptions(object):
  """
  Options available to select which tasks are run, e.g. read-only

  does the config apply to the action?
  is it out of date?
  is it in a ok state?
  """
  defaults = dict(
    resource=None,
    configuration=None,

    # default options:
    add=True, # run newly added configurations
    update=True, # run configurations that whose spec has changed but don't require a major version change
    repair=S.error # or 'degraded', run configurations that are not operational and/or degraded

    upgrade=False, # run configurations with major version changes or whose spec has changed
    all=False, # (re)run all configurations
    verify=False, # XXX2 discover first and set status if it differs from expected state
    readOnly=False, # only run configurations that won't alter the system
    dryRun=False, # XXX2
    requiredOnly=False,
    revertObsolete=False #revert
    )

  def __init__(self, **kw):
    self.__dict__.update(kw.update(self.defaults))

class Job(Operational):
  # XXX2 a saved job includes all the configurations run including
  # those that were notapplied to a resource (and therefore maybe not be associated with any resource)

  def __init__(self, rootResource, specs, jobOptions):
    self.__dict__.update(jobOptions)
    self.wantedSpecs = specs
    self.rootResource = rootResource
    self.tasks = []

  def status(self):
    'same rules as resource for the tasks specified for that run'
    # XXX0

  def addTask(self, task):
    self.tasks.append(task)

  def includeTask(self, config, lastChange):
    """
spec (config):
  intent: discover instantiate revert
  config
  version

status (lastChange):
  state: ok degraded error notpresent
  XXX1 current runtime state compared to requirements for last applied spec:
    no longer needed, misconfigured, error/degraded, missing/should be applied
    (only discovered at runtime as state is updated but persisted for next run)
  action: discover instantiate revert

status compared to current spec is different: compare difference for each:
  config: same different missing orphan
  intent vs. action: (d, i) (i, d) (i, r) (r, i) (d, r) (r, d)
  version: newer older
    """
    assert config or lastChange
    if self.all and config:
      return config
    if config and not lastChange:
      if self.add:
        return config
      else:
        return None
    elif lastChange and not config:
      if self.revertObsolete:
        return lastChange.spec.copy(intent=A.revert)
      if self.all:
        return lastChange.spec
    elif lastChange.spec != config:
      # the user changed the configuration:
      if config.intent == A.revert and lastChange.status == S.notpresent:
        return None # nothing to revert
      if self.upgrade:
        return config
      if lastChange.status == S.notpresent and lastChange.spec.intent != config.intent and self.add:
        # this case is essentially a re-added config, so re-run it
        return config
      if self.update:
        # apply the new configuration unless it will trigger a major version change
        if config.intent != A.revert and lastChange.spec.majorVersion != config.majorVersion:
          return config
    # there isn't a new config to run, see if the last applied config needs to be re-run
    return self.checkForRepair(lastChange)

  def checkForRepair(self, lastChange):
    assert lastChange
    if lastChange.status == S.ok or not self.repair:
        return None
    if self.repair == "degraded":
      return lastChange.spec
    elif lastChange.state == S.degraded:
      assert self.repair == 'error'
      return None
    else:
      assert self.repair == 'error'
      return lastChange.spec

  # NOPE:

  # predictability, clarity, static analysis
  # correctness: state changes are live
  # simplicity / understandable, easy to use and implement
  # state changes may place prior configurations in a obsolete, error/degraded, or outdated/misconfigured state

  def findMatchingConfiguration(self, config):
    resource = self.rootResource.findResource(config.target)
    if not resource:
      return None
    return resource.findConfiguration(config.name)

  def getCurrentConfigurations(self):
    for resource in self.rootResource.getSelfAndDescendents():
      for config in resource.configurations:
        yield config

  def getCandidateTasksOld(self):
    """
    Find candidate tasks

    Given declared spec, current status, and job options, generate selector

    does the config apply to the action?
    is it out of date?
    is it in a ok state?
    has its configuration changed?
    has its dependencies changed?
    are the resources it modifies in need of repair?
    manual override (include / skip)


    # intent: discover instantiate revert
    # version
    # configuration
    """
    matched = []
    for config in self.wantedSpecs:
      lastChange = self.findMatchingConfiguration(config) # dynamic, depends on resources
      if lastChange:
        matched.append(lastChange)
      config = self.includeTask(config, lastChange)
      if config and not self.filterConfig(config):
        yield Task(config, lastChange)

    if self.all or self.revertObsolete:
      for change in self.getCurrentConfigurations(): # dynamic, depends on resources
        if lastChange in matched:
          continue
        # it's an orphaned config
        config = self.includeTask(None, change)
        if config and not self.filterConfig(config):
          yield Task(config, change)

  def isConfigAlreadyHandled(self, config):
    return False #XXX1

  def findConfigurations(self, resource):
    for config in self.wantedSpecs:
      if config.target == resource.name:
        yield config
      # XXX3 to support rule-based configurations:
      # if config.matches(resource):
      #   if config.isTemplate:
      #     yield config.copy(target=resource.name)
      #   else:
      #     yield config

  def getCandidateTasks(self):
    # list of resources yielded here may dynamically change if tasks are run during iteration
    # we do this so as to reflect the state of the system as accurately as possible when tasks are run
    # but this means added resources whose parent has already been iterated over would be skipped
    # and updates to a resource already iterated over may render it inconsistent with the last run
    # XXX2 the runtime will have to keep track of these and generate tasks for them
    for resource in self.rootResource.getSelfAndDescendents():
      existing = dict((config.name, config) for config in resource.configurations)
      for config in self.findConfigurations(resource)
        if self.isConfigAlreadyHandled(config):
          # configuration may have premptively run while executing another task
          continue
        lastChange = existing.pop(config.name, None)
        config = self.includeTask(config, lastChange)
        if config and self.filterConfig(config):
            yield Task(self, config, lastChange)

      if self.all or self.revertObsolete:
        for change in existing.values():
          # it's an orphaned config
          config = self.includeTask(None, change)
          if self.isConfigAlreadyHandled(config):
            # configuration may have premptively run while executing another task
            continue
          if config and not self.filterConfig(config):
            yield Task(self, config, change)

  def filterConfig(self, config)
    if self.readOnly and config.intent != 'discover':
      return None
    if self.requiredOnly and not config.required:
      return None
    if self.resource and config.target != self.resource:
      return None
    if self.configuration and config.name != self.configuration:
      return None
    return config

  def runTask(self, task):
    """
    During each task run:
    * Notification of metadata changes that reflect changes made to resources
    * Notification of add or removing dependency on a resource or properties of a resource
    * Notification of creation or deletion of a resource
    * Requests a resource with requested metadata, if it doesn't exist, a task is run to make it so
    (e.g. add a dns entry, install a package).
    XXX1 need a way for configurator to declare that is the manager of a particular resource or type of resource or metadata so we know to handle that request
    """
    # XXX2 recursion or loop detection
    generator = task.start()
    change = None
    while True:
      result = generator.send(change)
      if isinstance(result, Status):
        generator.close()
        task.finished(result)
        return result
      elif isinstance(result, Task):
        change = self.runTask(result)
      else:
        raise GitErOpError('unexpected result from configurator')

class Runner(object):
  def __init__(self, rootResource, specs):
    self.rootResource = rootResource
    self.specs = specs

  def createJob(self, joboptions):
    """
    Selects task to run based on job options and starting state of manifest
    """
    return Job(self.rootResource, self.specs, joboptions)

  def shouldRunTask(self, task):
    """
    Checked at runtime right before each task is run

    * check "when" conditions to see if it should be run
    * check task if it should be run
    """
    priority = task.configurator.shouldRun(task)
    task.newConfiguration.priority = priority
    return priority > Priority.skip

  def canRunTask(self, task):
    """
    Checked at runtime right before each task is run

    * validate parameters
    * check "required"/pre-conditions to see if it can be run
    * check task if it can be run
    """
    return (task.validateParams()
            and task.configurationSpec.canRun(task.newConfiguration)
            and task.configurator.canRun(task))

  def shouldAbort(self, task, status):
    return False #XXX1

  def checkStatusAfterRun(self, task, status):
    """
    After each task has run:
    * Check that it provided the metadata it declared it would provide
    * Check dependencies:
    ** check that runtime-(post-)conditions still hold for configurations that might have been affected by changes
    ** check for configurations whose parameters might have been affected by changes, mark them as "configuration changed"
    (simple implementation for both: check all configurations (requires saving previous inputs))
    ** check for orphaned resources and mark them as orphaned
      (a resource is orphaned if it was added as a dependency and no longer has dependencies)
      (orphaned resources can be deleted by the configuration/configurator that created them or manages that type)
    """
    #XXX0
    # XXX2 check ensures
    self.checkPostConditions()
    # configurations changed
    # orphaned resources
    return status

  def checkPostConditions(self):
    """
    Has the status of any of configurations gotten worse?
    """
    # XXX1 getConfigurations()
    # XXX2 test that if notapplied use post-conditions from last applied configuration
    return Operational.aggregateStatus(
      configuration.statusFromConditions() for configuration in self.getConfigurations()
    )

  def run(self, joboptions):
    """
    """
    job = self.createJob(joboptions)
    for task in job.getCandidateTasks():
      job.addTask(task)
      if not self.shouldRunTask(task):
        continue
      if not self.canRunTask(task):
        continue

      status = job.runTask(task)
      # if XXX1 error
      # on failure just abort run or skip
      self.checkStatusAfterRun(task, status)
      self.save(task, status)

      if self.shouldAbort(task, status):
        break

    if job.modifiedState: #XXX1
      self.saveJob(job)

##### XXX1 move to test
def testGenerator(task):
  """
  Run is a generator, yields the result of running the task or a subtask
  """
  status = yield task.createSubTask(TestConfig("subtask"))
  print('got status ' + str(status))
  #if (status.failed)
  #yield 'huh'
  yield status

class TestConfig(Configuration):
  def generator(self, task):
    yield status

  def __init__(self, name):
    super(TestConfig, self,).__init__(self.generator, name)

def test():
  return Job().runTask(Task(Configuration(testGenerator, 'start')))

print('runtask ' + str(test()))
